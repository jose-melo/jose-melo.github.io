<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>Frequencia_Natural.Classificador.ClassificadorTp API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Frequencia_Natural.Classificador.ClassificadorTp</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8

import scipy as sci
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import plotly.express as px
from sklearn import svm
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import cross_val_predict
from sklearn.model_selection import KFold
from sklearn.metrics import confusion_matrix
import itertools

class SVM_classifier:
    
    &#39;&#39;&#39;
        A class used to represent the regressor.
        
        The idea is to predict what should be
        the value of the natural period given
        that there was no failure. 
        
        The main algorithm used is the SVM.


        Attributes
        ----------
        predictors : matrix[-1, 9]
            in order (offX, offY, offYaw, stdX, stdY, stdZ, stdRol, stdPitch, stdYaw)
        errorTX, errorTY : array
            diferences between T_estimated - T_predicted
        
        Methods
        ----------
        ### constructor():\n 
        The input is the path where one can take the values of:\n
        TX, TY, TYaw, offX, offY, offYaw, stdX, stdY, stdZ, stdRol, stdPitch, stdYaw)
            
        ### preProcessing():\n
          Prepare the data of the 9 predictors\n
          Prepare the train_data in case of training
        
        ### training():
          Instantiate and train the SVM regressor
        
        ### predict(predictors):
          Predict the values of natural period
          
          * params: 
            1. **predictors :** Input of the svm regressor in order to predict Tp values
        
        ### setError(TX_target, TY_target, TYaw_target):
          Calculates the error: T_estimated - T_predicted
            
          * params:
            1. **TX_target   :** Calculated from the estimator
            2. **TY_target   :** Calculated from the estimator
            3. **TYaw_target :** Calculated from the estimator
                    
        ### plotErrorGraph(TX_target, TY_target, TYaw_target, predictors, failureLine):

          It plots interactive graphs of the error for each axis (X, Y, Yaw)
            
          * params:
            1. **TX_target   :** Calculated from the estimator
            2. **TY_target   :** Calculated from the estimator
            3. **predictors  :** Input of the svm regressor in order to predict Tp values
            4. **failureLine :** The line that failed
           
        &#39;&#39;&#39; 
    
    def __init__(self, path1, path2=None, label=&#39;N&#39;):
        if path2 == None:
            SVM_classifier.load1(self, path1)
        else:
            SVM_classifier.load2(self, path1, path2)
        self.parsing = {&#39;offX&#39;: self.offX,
                        &#39;offY&#39;: self.offY,
                        &#39;offYaw&#39;: self.offYaw,
                        &#39;stdX&#39;: self.stdX,
                        &#39;stdY&#39;: self.stdY,
                        &#39;stdZ&#39;: self.stdZ,
                        &#39;stdRoll&#39;:self.stdRoll,
                        &#39;stdPitch&#39;: self.stdPitch,
                        &#39;stdYaw&#39;: self.stdYaw,
                        &#39;TX&#39;: self.TX,
                        &#39;TY&#39;: self.TY,
                        &#39;TYaw&#39;: self.TYaw,
                        &#39;TYaw2&#39;: self.TYaw2
                       }
        
        self.label = label
    
    def load2(self, path1, path2):
        &#39;&#39;&#39;
            Loads the training data when 2 files are needed.

        &#39;&#39;&#39;
        #print(&#34;Loading data from files: no failure&#34;)
        ini = time.time()
        self.offX = SVM_classifier.carrega(&#39;offX.txt&#39;, path1, path2)
        self.offY = SVM_classifier.carrega(&#39;offY.txt&#39;, path1, path2)
        self.offYaw = SVM_classifier.carrega(&#39;offYaw.txt&#39;, path1, path2)
        self.stdX = SVM_classifier.carrega(&#39;stdX.txt&#39;, path1, path2)
        self.stdY = SVM_classifier.carrega(&#39;stdY.txt&#39;, path1, path2)
        self.stdZ = SVM_classifier.carrega(&#39;stdZ.txt&#39;, path1, path2)
        self.stdRoll = SVM_classifier.carrega(&#39;stdRoll.txt&#39;, path1, path2)
        self.stdPitch = SVM_classifier.carrega(&#39;stdPitch.txt&#39;, path1, path2)
        self.stdYaw = SVM_classifier.carrega(&#39;stdYaw.txt&#39;, path1, path2)
        self.TX = SVM_classifier.carrega(&#39;TX.txt&#39;, path1, path2)
        self.TY = SVM_classifier.carrega(&#39;TY.txt&#39;, path1, path2)
        self.TYaw = SVM_classifier.carrega(&#39;TYaw.txt&#39;, path1, path2)
        self.TYaw2 = SVM_classifier.carrega(&#39;TYaw2.txt&#39;, path1, path2)
        fini = time.time()
        #print(&#34;Finished: &#34;, fini-ini, &#34; s&#34;)
    
    def load1(self, path):
        &#39;&#39;&#39;
            Loads the training data from 1 file.

        &#39;&#39;&#39;
        #print(&#34;Loading data from: &#34;+path)
        ini = time.time()
        self.offX = SVM_classifier.carrega2(&#39;offX.txt&#39;, path)
        self.offY = SVM_classifier.carrega2(&#39;offY.txt&#39;, path)
        self.offYaw = SVM_classifier.carrega2(&#39;offYaw.txt&#39;, path)
        self.stdX = SVM_classifier.carrega2(&#39;stdX.txt&#39;, path)
        self.stdY = SVM_classifier.carrega2(&#39;stdY.txt&#39;, path)
        self.stdZ = SVM_classifier.carrega2(&#39;stdZ.txt&#39;, path)
        self.stdRoll = SVM_classifier.carrega2(&#39;stdRoll.txt&#39;, path)
        self.stdPitch = SVM_classifier.carrega2(&#39;stdPitch.txt&#39;, path)
        self.stdYaw = SVM_classifier.carrega2(&#39;stdYaw.txt&#39;, path)
        self.TX = SVM_classifier.carrega2(&#39;TX.txt&#39;, path)
        self.TY = SVM_classifier.carrega2(&#39;TY.txt&#39;, path)
        self.TYaw = SVM_classifier.carrega2(&#39;TYaw.txt&#39;, path)
        self.TYaw2 = SVM_classifier.carrega2(&#39;TYaw2.txt&#39;, path)
        fini = time.time()
        #print(&#34;Finished: &#34;, fini-ini, &#34; s&#34;)
        
        
    def plotGraph(self, var):
        &#39;&#39;&#39;
            ### Plots a scatter graph of the Offset X and Offset Y. The color is the natural period.

              - params: 
                1. **var:** Variable (TX, TY, TYaw) to color the graph
        &#39;&#39;&#39;
        variable = self.parsing[var]
        
        df = pd.DataFrame({&#34;Offset X (m)&#34;:self.offX[:len(variable)], &#34;Offset Y (m)&#34;:self.offY[:len(variable)], &#34;Tp &#34;+str(var): np.array(variable)})
        fig = px.scatter(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, height=600, width=1200, color=&#34;Tp &#34;+str(var), title=&#34;Natural period &#34;+str(var))
        fig.show()
        
    def preProcessing(self):
        &#39;&#39;&#39;
            ### Prepare the data of the 9 predictors
            1. offX 
            2. offY 
            3. offYaw 
            4. stdX 
            5.stdY 
            6. stdZ 
            7. stdRoll 
            8. stdPitch 
            9. stdYaw
            ### Prepare the train_data in case of training
        &#39;&#39;&#39;  
        #print(&#34;Preprocessing data&#34;)
        f = []
        f.append(np.array(self.offX).reshape(-1, 1))
        f.append(np.array(self.offY).reshape(-1, 1))
        f.append(np.array(self.offYaw).reshape(-1, 1))
        f.append(np.array(self.stdX).reshape(-1, 1))
        f.append(np.array(self.stdY).reshape(-1, 1))
        f.append(np.array(self.stdZ).reshape(-1, 1))
        f.append(np.array(self.stdRoll).reshape(-1, 1))
        f.append(np.array(self.stdPitch).reshape(-1, 1))
        f.append(np.array(self.stdYaw).reshape(-1, 1))
        f = tuple(f)    
        
        self.predictors = np.hstack(f)
        #print(&#34;Predictors: &#34;, self.predictors)
        
        self.X_train = self.predictors[:]
        scaler = StandardScaler()
        scaler.fit(self.X_train)
        self.X_train = scaler.transform(self.X_train)
    
    def preProcessingClassifier_Var(self, case, active_variables):
        &#39;&#39;&#39;
            ### Treat the data for the classifier.
            #### Uses stardard normalization.
              
              - params:
                1. **case:** Object that holds the classifier input
                      - Mean X offset
                      - Mean Y offset
                      - Mean Yaw offset
                      - X standard deviation
                      - Y standard deviation
                      - Z standard deviation
                      - Roll standard deviation
                      - Pitch standard deviation
                      - Yaw standanrd deviation

                2. **active_variables:** Boolean array that determines the variables used in classification

        &#39;&#39;&#39;

        global teste
    
        self.predict(case.predictors)
        self.setError(case.TX, case.TY)
        f = []
        if(active_variables[0]):f.append(np.array(self.errorTX[:2900]).reshape(-1, 1))
        if(active_variables[1]):f.append(np.array(self.errorTY[:2900]).reshape(-1, 1))
        if(active_variables[2]):f.append(np.array(case.offX[:2900]).reshape(-1, 1))
        if(active_variables[3]):f.append(np.array(case.offY[:2900]).reshape(-1, 1))
        if(active_variables[4]):f.append(np.array(case.offYaw[:2900]).reshape(-1, 1))
        if(active_variables[5]):f.append(np.array(case.stdX[:2900]).reshape(-1, 1))
        if(active_variables[6]):f.append(np.array(case.stdY[:2900]).reshape(-1, 1))
        if(active_variables[7]):f.append(np.array(case.stdZ[:2900]).reshape(-1, 1))
        if(active_variables[8]):f.append(np.array(case.stdRoll[:2900]).reshape(-1, 1))
        if(active_variables[9]):f.append(np.array(case.stdPitch[:2900]).reshape(-1, 1))
        if(active_variables[10]):f.append(np.array(case.stdYaw[:2900]).reshape(-1, 1))
        f = tuple(f)   
  
        g = []
        g.append(np.array(2900*[case.label]).reshape(-1, 1))
        g = tuple(g)

        return np.hstack(f), np.hstack(g)    
    
    def preProcessingClassifier(self, predictors, active_variables):
    
        &#39;&#39;&#39;
            ### Treat the data for the classifier.

              - params:
                1. **predictors:** list of objects for each group of line 
                2. **active_variables:** Boolean array that determines the variables used in classification

        &#39;&#39;&#39;

        f = []
        g = []
        for case in predictors:
            aux = self.preProcessingClassifier_Var(case, active_variables)
            f.append(aux[0])
            g.append(aux[1])
        f = tuple(f)
        g = tuple(g)
        
        self.inputClassifier = np.vstack(f)
        self.outputClassifier = np.vstack(g)
        
    
    def trainingVar(self, var): 
        &#39;&#39;&#39;
            ### Train the SVR with the data loaded previously.
              
              - params:
                1. **var:** variable to train (TX, TY, TYaw)  
              - returns:
                1. **regressor:** the SVM regressor trained
        &#39;&#39;&#39;
        variable = self.parsing[var]
        
        print(&#34;Training for: &#34;, var)
        
        ini = time.time()
    
        responseScale = sci.stats.iqr(variable)
        
        boxConstraint = responseScale/1.349;
        #boxConstraint = 135
        #gamma = 1/9
        #gamma = 0.01
        gamma=&#39;auto&#39;
        #epsilon = 1
        epsilon = 2*responseScale/13.49;
        
        regressor = svm.SVR(&#39;rbf&#39;, C=boxConstraint, gamma=gamma, epsilon=epsilon)
        regressor.fit(self.X_train, variable)
        fini = time.time()
        
        print(&#34;Finished: &#34;, fini - ini)
        
        return regressor
        
    def training(self):
        &#39;&#39;&#39;
            ### Instantiate and train the SVM regressor
            
            1. **BoxConstraint:** Interquartile range of the variable / 1.349
            2. **Epsilon:** 2*IQR / 13.49
        
        &#39;&#39;&#39;        
        print(&#34;Training initialization&#34;)
        ini = time.time()
        self.regressorTX = self.trainingVar(&#39;TX&#39;)
        self.regressorTY = self.trainingVar(&#39;TY&#39;)
        self.regressorTYaw = self.trainingVar(&#39;TYaw&#39;)
        
        #self.regressorTYaw2 = SVM_classifier.trainingVar(&#39;TYaw2&#39;)
        
        fini = time.time()
        print(&#34;Finished training - Total elapsed time: &#34;, fini - ini)
        
    def predictVar(self, var, regressor, predictors):

        &#39;&#39;&#39;
            ### Predicts the values of natural period in the given variable var

              - params:
                1. **var         :** variable to calculate the natural period
                2. **regressor   :** trained SVM regressor
                3. **predictors  :** input of the regressor

        &#39;&#39;&#39;
        variable = self.parsing[var]

        scaler = StandardScaler()
        scaler.fit(predictors)
        predictors = scaler.transform(predictors)

        print(&#34;Predicting &#34;, var)
        ini = time.time()
        Tpredicted = regressor.predict(predictors)
        fini = time.time()
        print(&#34;Finished: &#34;, fini - ini)
        
        return Tpredicted
        
    def predict(self, predictors):
        
        &#39;&#39;&#39;
            ### Predict the values of natural period

              - params: 
                1. **predictors :** Input of the svm regressor in order to predict Tp values
        &#39;&#39;&#39;

        #print(&#34;Prediction initialiation: &#34;)
        #init = time.time()
        
        self.TXpredicted = self.predictVar(&#39;TX&#39;, self.regressorTX, predictors)
        self.TYpredicted = self.predictVar(&#39;TY&#39;, self.regressorTY, predictors)
        self.TYawpredicted = self.predictVar(&#39;TYaw&#39;, self.regressorTYaw, predictors)
        #TYaw2predicted = SVM_classifier.predictVar(&#39;TYaw2&#39;, predictors)
        
        #finit = time.time()
        
        #print(&#34;Prediction initialiation: &#34;, finit-init)
    
    def setErrorVar(self, var, T_target):
        &#39;&#39;&#39;
            ### Calculates the error for the given variable in var

              - params:
                1. **T_target :** Calculated from the estimator
                2. **var      :** Variable (TX, TY, TYaw) from the regressor
        &#39;&#39;&#39;        
        if var == &#39;TX&#39;: variable = self.TXpredicted
        if var == &#39;TY&#39;: variable = self.TYpredicted
        if var == &#39;TYaw&#39;: variable = self.TYawpredicted
        
        error = []
        for i in range(min(len(T_target), len(variable))):
            error.append(T_target[i] - variable[i])
        
        return error
    
    def setError(self, TX_target, TY_target):
        &#39;&#39;&#39;
            ### Calculates the error: T_estimated - T_predicted

              - params:
                1. **TX_target:** Calculated from the estimator
                2. **TY_target:** Calculated from the estimator
                3. **TYaw_target:** Calculated from the estimator
        &#39;&#39;&#39;        
        self.errorTX = self.setErrorVar(&#39;TX&#39;, TX_target)
        self.errorTY = self.setErrorVar(&#39;TY&#39;, TY_target)
   
    def plotErrorGraphVar(self, var, offXTest, offYTest,T_predicted, T_target, error, failureLine):
        &#39;&#39;&#39;
            ### It plots interactive graphs of the error for the given variable var.
              - The plots are:
                1. Scatter of Tp predicted and estimated over X offset
                2. Scatter of Tp predicted and estimated over Y offset
                3. Scatter of X offset over Y offser where the color is the error.
                4. Histogram of the error
                5. 3D scatter plot
            
              - params:
                1. **T_target:** Calculated from the estimator
                2. **var:** Variable TX, TY, or TYaw
                3. **offXTest:** X offset values from the broken line
                3. **offYTest:** Y offset values from the broken line  
                3. **T_predicted:** Tp values from the regressor results
                3. **T_target:** Tp values from the estimator results
                3. **error:** Error measured as T_target - T_predicted
                4. **failureLine:** The line that failed
        &#39;&#39;&#39;                
        plt.figure(figsize=(20, 5))
        plt.title(&#34;First test with SVM regression: &#34; + str(var))
        plt.scatter(offXTest[:len(T_target)], T_target, label=failureLine)
        plt.scatter(offXTest[:len(T_target)], T_predicted[:len(T_target)], label=&#39;no_failure&#39;)
        plt.xlabel(&#34;OffsetX (m)&#34;)
        plt.ylabel(&#34;Natural period (s)&#34;)
        plt.legend()

        plt.figure(figsize=(20, 5))
        plt.title(&#34;First test with SVM regression: &#34; + str(var))
        plt.scatter(offYTest[:len(T_target)], T_target, label=failureLine)
        plt.scatter(offYTest[:len(T_target)], T_predicted[:len(T_target)], label=&#39;no_failure&#39;)
        plt.xlabel(&#34;OffsetY (m)&#34;)
        plt.ylabel(&#34;Natural period (s)&#34;)
        plt.legend()

        df = pd.DataFrame({&#34;Offset X (m)&#34;:offXTest[:len(T_target)],&#34;Offset Y (m)&#34;:offYTest[:len(T_target)], &#34;Error_&#34;+failureLine+&#34; (s)&#34;:np.array(error), &#39;T_failure&#39;:T_target[:len(T_target)], &#39;T_predicted&#39;:T_predicted[:len(T_target)]})
        fig = px.scatter(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, height=600, width=1200, color=&#34;Error_&#34;+failureLine+&#34; (s)&#34;, title=&#34;Test with SVM regression &#34;+var+&#34;: Error&#34;&#34;Error_&#34;+failureLine)
        fig.show()
        
        fig = px.histogram(df, x=&#34;Error_&#34;+failureLine+&#34; (s)&#34;, title=&#34;Error Histogram &#34; +var+ &#34; Mean: &#34;+str(np.mean([x for x in error if str(x) != &#39;nan&#39;])))
        fig.show()
        
        Tp = []
        colorTp = []
        sizeTp = []
        tam = 10
        Tp.append(T_target[0])
        sizeTp.append(tam)
        colorTp.append(0)
        for i in range(1, len(T_target)):
            Tp.append(T_target[i])
            colorTp.append(0.25)
            sizeTp.append(tam)
        
        
        Tp.append(T_predicted[0])
        colorTp.append(1)
        sizeTp.append(tam)
        for i in range(1, len(T_target)):
            Tp.append(T_predicted[i])
            colorTp.append(0.75)
            sizeTp.append(tam)
        df = pd.DataFrame({&#34;Offset X (m)&#34;:offXTest[:len(T_target)] + offXTest[:len(T_target)],&#34;Offset Y (m)&#34;:offYTest[:len(T_target)]+offYTest[:len(T_target)],&#39;Tp&#39;:np.array(Tp), &#39;Class&#39;:np.array(colorTp)})
       
        fig = px.scatter_3d(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, z=&#39;Tp&#39;, height=600, width=1140, color=&#39;Class&#39;, title=&#34;Test with SVM regression &#34;+var)      
        fig.show()
                
        
    def plotErrorGraph(self, TX_target, TY_target, TYaw_target, predictors, failureLine):
        &#39;&#39;&#39;
            ### It plots interactive graphs of the error for each axis (X, Y, Yaw)
            
              - params:
                1. **TX_target:** Calculated from the estimator
                2. **TY_target:** Calculated from the estimator
                3. **predictors:** Input of the svm regressor in order to predict Tp values
                4. **failureLine:** The line that failed
        &#39;&#39;&#39;        
        offXTest = []
        for i in range(len(predictors)):
            offXTest.append(predictors[i][0])
        offYTest = []
        for i in range(len(predictors)):
            offYTest.append(predictors[i][1])
        
        self.plotErrorGraphVar(&#39;TX&#39;, offXTest, offYTest, self.TXpredicted, TX_target, self.errorTX, failureLine)
        self.plotErrorGraphVar(&#39;TY&#39;, offXTest, offYTest, self.TYpredicted, TY_target, self.errorTY, failureLine)
        self.plotErrorGraphVar(&#39;TYaw&#39;, offXTest, offYTest, self.TYawpredicted, TYaw_target, self.errorTYaw, failureLine)
        

    def predictClasses(self):
        &#39;&#39;&#39;
            ### Predict and plot the confusion matrix of the classifier
            #### **Validation:** 5-fold cross-validation


        &#39;&#39;&#39;
        classifier = svm.SVC(kernel=&#39;rbf&#39;, C=100, gamma=0.35)#1/np.sqrt(2.8))
        scaler = StandardScaler()
        scaler.fit(self.inputClassifier)
        X = scaler.transform(self.inputClassifier)
        y = self.outputClassifier.ravel()

        scores = cross_val_score(classifier, X, y, cv=5)
        print(&#34;Accuracy: %0.2f (+/- %0.2f)&#34; % (scores.mean(), scores.std() * 2))
    
        nlabels = 5
        
        kf = KFold(5, True)
        kf.get_n_splits(X)

        matrix = [[0 for i in range(nlabels)] for k in range(nlabels)]

        for train_index, test_index in kf.split(X):

            X_train, X_test = X[train_index], X[test_index]
            y_train, y_test = y[train_index], y[test_index]

            classifier.fit(X_train, y_train)

            #plot_confusion_matrix(classifier, X_test, y_test)
            y_predict = classifier.predict(X_test)
            m = confusion_matrix(y_test,y_predict)

            #df = pd.DataFrame({&#34;stdY&#34;:column(X_test, 0),&#34;stdYaw&#34;:column(X_test, 1),&#39;label&#39;:np.array(y_test)})
            #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Test case&#34;)  
            #fig.show()

            #df = pd.DataFrame({&#34;stdY&#34;:column(X_train, 0)[classifier.support_],&#34;stdYaw&#34;:column(X_train, 1)[classifier.support_],&#39;label&#39;:np.array(y_train[classifier.support_])})
            #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Support vectors&#34;)  
            #fig.show()

            ox0 = []
            ox1 = []
            erro = []
            for i in range(len(y_test)):
                if(y_test[i] != y_predict[i]):
                    ox0.append(X_test[i][0])
                    ox1.append(X_test[i][1])
                    erro.append(y_predict[i])

            #df = pd.DataFrame({&#34;stdY&#34;:ox0,&#34;stdYaw&#34;:ox1,&#39;label&#39;:np.array(erro)})
            #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Wrong values&#34;)  
            #fig.show()

            for i in range(len(m)):
                for j in range(len(m)):
                    matrix[i][j] += m[i][j]

            classes_names = [&#39;L05&#39;, &#39;L09&#39;, &#39;L12&#39;, &#39;L18&#39;, &#39;N&#39;]
        plot_cmatrix(matrix = np.array(matrix), proportions    = True, class_names = classes_names,title = &#34;Confusion Matrix&#34;,gradient=&#39;GnBu&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier"><code class="flex name class">
<span>class <span class="ident">SVM_classifier</span></span>
<span>(</span><span>path1, path2=None, label='N')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to represent the regressor.</p>
<p>The idea is to predict what should be
the value of the natural period given
that there was no failure. </p>
<p>The main algorithm used is the SVM.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>predictors</code></strong> :&ensp;<code>matrix[-1, 9]</code></dt>
<dd>in order (offX, offY, offYaw, stdX, stdY, stdZ, stdRol, stdPitch, stdYaw)</dd>
<dt><strong><code>errorTX</code></strong>, <strong><code>errorTY</code></strong> :&ensp;<code>array</code></dt>
<dd>diferences between T_estimated - T_predicted</dd>
</dl>
<h2 id="methods">Methods</h2>
<h3 id="constructor">constructor():</h3>
<p>The input is the path where one can take the values of:</p>
<p>TX, TY, TYaw, offX, offY, offYaw, stdX, stdY, stdZ, stdRol, stdPitch, stdYaw)</p>
<h3 id="preprocessing">preProcessing():</h3>
<p>Prepare the data of the 9 predictors</p>
<p>Prepare the train_data in case of training</p>
<h3 id="training">training():</h3>
<p>Instantiate and train the SVM regressor</p>
<h3 id="predictpredictors">predict(predictors):</h3>
<p>Predict the values of natural period</p>
<ul>
<li>params: <ol>
<li><strong>predictors :</strong> Input of the svm regressor in order to predict Tp values</li>
</ol>
</li>
</ul>
<h3 id="seterrortx_target-ty_target-tyaw_target">setError(TX_target, TY_target, TYaw_target):</h3>
<p>Calculates the error: T_estimated - T_predicted</p>
<ul>
<li>params:<ol>
<li><strong>TX_target
:</strong> Calculated from the estimator</li>
<li><strong>TY_target
:</strong> Calculated from the estimator</li>
<li><strong>TYaw_target :</strong> Calculated from the estimator</li>
</ol>
</li>
</ul>
<h3 id="ploterrorgraphtx_target-ty_target-tyaw_target-predictors-failureline">plotErrorGraph(TX_target, TY_target, TYaw_target, predictors, failureLine):</h3>
<p>It plots interactive graphs of the error for each axis (X, Y, Yaw)</p>
<ul>
<li>params:<ol>
<li><strong>TX_target
:</strong> Calculated from the estimator</li>
<li><strong>TY_target
:</strong> Calculated from the estimator</li>
<li><strong>predictors
:</strong> Input of the svm regressor in order to predict Tp values</li>
<li><strong>failureLine :</strong> The line that failed</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SVM_classifier:
    
    &#39;&#39;&#39;
        A class used to represent the regressor.
        
        The idea is to predict what should be
        the value of the natural period given
        that there was no failure. 
        
        The main algorithm used is the SVM.


        Attributes
        ----------
        predictors : matrix[-1, 9]
            in order (offX, offY, offYaw, stdX, stdY, stdZ, stdRol, stdPitch, stdYaw)
        errorTX, errorTY : array
            diferences between T_estimated - T_predicted
        
        Methods
        ----------
        ### constructor():\n 
        The input is the path where one can take the values of:\n
        TX, TY, TYaw, offX, offY, offYaw, stdX, stdY, stdZ, stdRol, stdPitch, stdYaw)
            
        ### preProcessing():\n
          Prepare the data of the 9 predictors\n
          Prepare the train_data in case of training
        
        ### training():
          Instantiate and train the SVM regressor
        
        ### predict(predictors):
          Predict the values of natural period
          
          * params: 
            1. **predictors :** Input of the svm regressor in order to predict Tp values
        
        ### setError(TX_target, TY_target, TYaw_target):
          Calculates the error: T_estimated - T_predicted
            
          * params:
            1. **TX_target   :** Calculated from the estimator
            2. **TY_target   :** Calculated from the estimator
            3. **TYaw_target :** Calculated from the estimator
                    
        ### plotErrorGraph(TX_target, TY_target, TYaw_target, predictors, failureLine):

          It plots interactive graphs of the error for each axis (X, Y, Yaw)
            
          * params:
            1. **TX_target   :** Calculated from the estimator
            2. **TY_target   :** Calculated from the estimator
            3. **predictors  :** Input of the svm regressor in order to predict Tp values
            4. **failureLine :** The line that failed
           
        &#39;&#39;&#39; 
    
    def __init__(self, path1, path2=None, label=&#39;N&#39;):
        if path2 == None:
            SVM_classifier.load1(self, path1)
        else:
            SVM_classifier.load2(self, path1, path2)
        self.parsing = {&#39;offX&#39;: self.offX,
                        &#39;offY&#39;: self.offY,
                        &#39;offYaw&#39;: self.offYaw,
                        &#39;stdX&#39;: self.stdX,
                        &#39;stdY&#39;: self.stdY,
                        &#39;stdZ&#39;: self.stdZ,
                        &#39;stdRoll&#39;:self.stdRoll,
                        &#39;stdPitch&#39;: self.stdPitch,
                        &#39;stdYaw&#39;: self.stdYaw,
                        &#39;TX&#39;: self.TX,
                        &#39;TY&#39;: self.TY,
                        &#39;TYaw&#39;: self.TYaw,
                        &#39;TYaw2&#39;: self.TYaw2
                       }
        
        self.label = label
    
    def load2(self, path1, path2):
        &#39;&#39;&#39;
            Loads the training data when 2 files are needed.

        &#39;&#39;&#39;
        #print(&#34;Loading data from files: no failure&#34;)
        ini = time.time()
        self.offX = SVM_classifier.carrega(&#39;offX.txt&#39;, path1, path2)
        self.offY = SVM_classifier.carrega(&#39;offY.txt&#39;, path1, path2)
        self.offYaw = SVM_classifier.carrega(&#39;offYaw.txt&#39;, path1, path2)
        self.stdX = SVM_classifier.carrega(&#39;stdX.txt&#39;, path1, path2)
        self.stdY = SVM_classifier.carrega(&#39;stdY.txt&#39;, path1, path2)
        self.stdZ = SVM_classifier.carrega(&#39;stdZ.txt&#39;, path1, path2)
        self.stdRoll = SVM_classifier.carrega(&#39;stdRoll.txt&#39;, path1, path2)
        self.stdPitch = SVM_classifier.carrega(&#39;stdPitch.txt&#39;, path1, path2)
        self.stdYaw = SVM_classifier.carrega(&#39;stdYaw.txt&#39;, path1, path2)
        self.TX = SVM_classifier.carrega(&#39;TX.txt&#39;, path1, path2)
        self.TY = SVM_classifier.carrega(&#39;TY.txt&#39;, path1, path2)
        self.TYaw = SVM_classifier.carrega(&#39;TYaw.txt&#39;, path1, path2)
        self.TYaw2 = SVM_classifier.carrega(&#39;TYaw2.txt&#39;, path1, path2)
        fini = time.time()
        #print(&#34;Finished: &#34;, fini-ini, &#34; s&#34;)
    
    def load1(self, path):
        &#39;&#39;&#39;
            Loads the training data from 1 file.

        &#39;&#39;&#39;
        #print(&#34;Loading data from: &#34;+path)
        ini = time.time()
        self.offX = SVM_classifier.carrega2(&#39;offX.txt&#39;, path)
        self.offY = SVM_classifier.carrega2(&#39;offY.txt&#39;, path)
        self.offYaw = SVM_classifier.carrega2(&#39;offYaw.txt&#39;, path)
        self.stdX = SVM_classifier.carrega2(&#39;stdX.txt&#39;, path)
        self.stdY = SVM_classifier.carrega2(&#39;stdY.txt&#39;, path)
        self.stdZ = SVM_classifier.carrega2(&#39;stdZ.txt&#39;, path)
        self.stdRoll = SVM_classifier.carrega2(&#39;stdRoll.txt&#39;, path)
        self.stdPitch = SVM_classifier.carrega2(&#39;stdPitch.txt&#39;, path)
        self.stdYaw = SVM_classifier.carrega2(&#39;stdYaw.txt&#39;, path)
        self.TX = SVM_classifier.carrega2(&#39;TX.txt&#39;, path)
        self.TY = SVM_classifier.carrega2(&#39;TY.txt&#39;, path)
        self.TYaw = SVM_classifier.carrega2(&#39;TYaw.txt&#39;, path)
        self.TYaw2 = SVM_classifier.carrega2(&#39;TYaw2.txt&#39;, path)
        fini = time.time()
        #print(&#34;Finished: &#34;, fini-ini, &#34; s&#34;)
        
        
    def plotGraph(self, var):
        &#39;&#39;&#39;
            ### Plots a scatter graph of the Offset X and Offset Y. The color is the natural period.

              - params: 
                1. **var:** Variable (TX, TY, TYaw) to color the graph
        &#39;&#39;&#39;
        variable = self.parsing[var]
        
        df = pd.DataFrame({&#34;Offset X (m)&#34;:self.offX[:len(variable)], &#34;Offset Y (m)&#34;:self.offY[:len(variable)], &#34;Tp &#34;+str(var): np.array(variable)})
        fig = px.scatter(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, height=600, width=1200, color=&#34;Tp &#34;+str(var), title=&#34;Natural period &#34;+str(var))
        fig.show()
        
    def preProcessing(self):
        &#39;&#39;&#39;
            ### Prepare the data of the 9 predictors
            1. offX 
            2. offY 
            3. offYaw 
            4. stdX 
            5.stdY 
            6. stdZ 
            7. stdRoll 
            8. stdPitch 
            9. stdYaw
            ### Prepare the train_data in case of training
        &#39;&#39;&#39;  
        #print(&#34;Preprocessing data&#34;)
        f = []
        f.append(np.array(self.offX).reshape(-1, 1))
        f.append(np.array(self.offY).reshape(-1, 1))
        f.append(np.array(self.offYaw).reshape(-1, 1))
        f.append(np.array(self.stdX).reshape(-1, 1))
        f.append(np.array(self.stdY).reshape(-1, 1))
        f.append(np.array(self.stdZ).reshape(-1, 1))
        f.append(np.array(self.stdRoll).reshape(-1, 1))
        f.append(np.array(self.stdPitch).reshape(-1, 1))
        f.append(np.array(self.stdYaw).reshape(-1, 1))
        f = tuple(f)    
        
        self.predictors = np.hstack(f)
        #print(&#34;Predictors: &#34;, self.predictors)
        
        self.X_train = self.predictors[:]
        scaler = StandardScaler()
        scaler.fit(self.X_train)
        self.X_train = scaler.transform(self.X_train)
    
    def preProcessingClassifier_Var(self, case, active_variables):
        &#39;&#39;&#39;
            ### Treat the data for the classifier.
            #### Uses stardard normalization.
              
              - params:
                1. **case:** Object that holds the classifier input
                      - Mean X offset
                      - Mean Y offset
                      - Mean Yaw offset
                      - X standard deviation
                      - Y standard deviation
                      - Z standard deviation
                      - Roll standard deviation
                      - Pitch standard deviation
                      - Yaw standanrd deviation

                2. **active_variables:** Boolean array that determines the variables used in classification

        &#39;&#39;&#39;

        global teste
    
        self.predict(case.predictors)
        self.setError(case.TX, case.TY)
        f = []
        if(active_variables[0]):f.append(np.array(self.errorTX[:2900]).reshape(-1, 1))
        if(active_variables[1]):f.append(np.array(self.errorTY[:2900]).reshape(-1, 1))
        if(active_variables[2]):f.append(np.array(case.offX[:2900]).reshape(-1, 1))
        if(active_variables[3]):f.append(np.array(case.offY[:2900]).reshape(-1, 1))
        if(active_variables[4]):f.append(np.array(case.offYaw[:2900]).reshape(-1, 1))
        if(active_variables[5]):f.append(np.array(case.stdX[:2900]).reshape(-1, 1))
        if(active_variables[6]):f.append(np.array(case.stdY[:2900]).reshape(-1, 1))
        if(active_variables[7]):f.append(np.array(case.stdZ[:2900]).reshape(-1, 1))
        if(active_variables[8]):f.append(np.array(case.stdRoll[:2900]).reshape(-1, 1))
        if(active_variables[9]):f.append(np.array(case.stdPitch[:2900]).reshape(-1, 1))
        if(active_variables[10]):f.append(np.array(case.stdYaw[:2900]).reshape(-1, 1))
        f = tuple(f)   
  
        g = []
        g.append(np.array(2900*[case.label]).reshape(-1, 1))
        g = tuple(g)

        return np.hstack(f), np.hstack(g)    
    
    def preProcessingClassifier(self, predictors, active_variables):
    
        &#39;&#39;&#39;
            ### Treat the data for the classifier.

              - params:
                1. **predictors:** list of objects for each group of line 
                2. **active_variables:** Boolean array that determines the variables used in classification

        &#39;&#39;&#39;

        f = []
        g = []
        for case in predictors:
            aux = self.preProcessingClassifier_Var(case, active_variables)
            f.append(aux[0])
            g.append(aux[1])
        f = tuple(f)
        g = tuple(g)
        
        self.inputClassifier = np.vstack(f)
        self.outputClassifier = np.vstack(g)
        
    
    def trainingVar(self, var): 
        &#39;&#39;&#39;
            ### Train the SVR with the data loaded previously.
              
              - params:
                1. **var:** variable to train (TX, TY, TYaw)  
              - returns:
                1. **regressor:** the SVM regressor trained
        &#39;&#39;&#39;
        variable = self.parsing[var]
        
        print(&#34;Training for: &#34;, var)
        
        ini = time.time()
    
        responseScale = sci.stats.iqr(variable)
        
        boxConstraint = responseScale/1.349;
        #boxConstraint = 135
        #gamma = 1/9
        #gamma = 0.01
        gamma=&#39;auto&#39;
        #epsilon = 1
        epsilon = 2*responseScale/13.49;
        
        regressor = svm.SVR(&#39;rbf&#39;, C=boxConstraint, gamma=gamma, epsilon=epsilon)
        regressor.fit(self.X_train, variable)
        fini = time.time()
        
        print(&#34;Finished: &#34;, fini - ini)
        
        return regressor
        
    def training(self):
        &#39;&#39;&#39;
            ### Instantiate and train the SVM regressor
            
            1. **BoxConstraint:** Interquartile range of the variable / 1.349
            2. **Epsilon:** 2*IQR / 13.49
        
        &#39;&#39;&#39;        
        print(&#34;Training initialization&#34;)
        ini = time.time()
        self.regressorTX = self.trainingVar(&#39;TX&#39;)
        self.regressorTY = self.trainingVar(&#39;TY&#39;)
        self.regressorTYaw = self.trainingVar(&#39;TYaw&#39;)
        
        #self.regressorTYaw2 = SVM_classifier.trainingVar(&#39;TYaw2&#39;)
        
        fini = time.time()
        print(&#34;Finished training - Total elapsed time: &#34;, fini - ini)
        
    def predictVar(self, var, regressor, predictors):

        &#39;&#39;&#39;
            ### Predicts the values of natural period in the given variable var

              - params:
                1. **var         :** variable to calculate the natural period
                2. **regressor   :** trained SVM regressor
                3. **predictors  :** input of the regressor

        &#39;&#39;&#39;
        variable = self.parsing[var]

        scaler = StandardScaler()
        scaler.fit(predictors)
        predictors = scaler.transform(predictors)

        print(&#34;Predicting &#34;, var)
        ini = time.time()
        Tpredicted = regressor.predict(predictors)
        fini = time.time()
        print(&#34;Finished: &#34;, fini - ini)
        
        return Tpredicted
        
    def predict(self, predictors):
        
        &#39;&#39;&#39;
            ### Predict the values of natural period

              - params: 
                1. **predictors :** Input of the svm regressor in order to predict Tp values
        &#39;&#39;&#39;

        #print(&#34;Prediction initialiation: &#34;)
        #init = time.time()
        
        self.TXpredicted = self.predictVar(&#39;TX&#39;, self.regressorTX, predictors)
        self.TYpredicted = self.predictVar(&#39;TY&#39;, self.regressorTY, predictors)
        self.TYawpredicted = self.predictVar(&#39;TYaw&#39;, self.regressorTYaw, predictors)
        #TYaw2predicted = SVM_classifier.predictVar(&#39;TYaw2&#39;, predictors)
        
        #finit = time.time()
        
        #print(&#34;Prediction initialiation: &#34;, finit-init)
    
    def setErrorVar(self, var, T_target):
        &#39;&#39;&#39;
            ### Calculates the error for the given variable in var

              - params:
                1. **T_target :** Calculated from the estimator
                2. **var      :** Variable (TX, TY, TYaw) from the regressor
        &#39;&#39;&#39;        
        if var == &#39;TX&#39;: variable = self.TXpredicted
        if var == &#39;TY&#39;: variable = self.TYpredicted
        if var == &#39;TYaw&#39;: variable = self.TYawpredicted
        
        error = []
        for i in range(min(len(T_target), len(variable))):
            error.append(T_target[i] - variable[i])
        
        return error
    
    def setError(self, TX_target, TY_target):
        &#39;&#39;&#39;
            ### Calculates the error: T_estimated - T_predicted

              - params:
                1. **TX_target:** Calculated from the estimator
                2. **TY_target:** Calculated from the estimator
                3. **TYaw_target:** Calculated from the estimator
        &#39;&#39;&#39;        
        self.errorTX = self.setErrorVar(&#39;TX&#39;, TX_target)
        self.errorTY = self.setErrorVar(&#39;TY&#39;, TY_target)
   
    def plotErrorGraphVar(self, var, offXTest, offYTest,T_predicted, T_target, error, failureLine):
        &#39;&#39;&#39;
            ### It plots interactive graphs of the error for the given variable var.
              - The plots are:
                1. Scatter of Tp predicted and estimated over X offset
                2. Scatter of Tp predicted and estimated over Y offset
                3. Scatter of X offset over Y offser where the color is the error.
                4. Histogram of the error
                5. 3D scatter plot
            
              - params:
                1. **T_target:** Calculated from the estimator
                2. **var:** Variable TX, TY, or TYaw
                3. **offXTest:** X offset values from the broken line
                3. **offYTest:** Y offset values from the broken line  
                3. **T_predicted:** Tp values from the regressor results
                3. **T_target:** Tp values from the estimator results
                3. **error:** Error measured as T_target - T_predicted
                4. **failureLine:** The line that failed
        &#39;&#39;&#39;                
        plt.figure(figsize=(20, 5))
        plt.title(&#34;First test with SVM regression: &#34; + str(var))
        plt.scatter(offXTest[:len(T_target)], T_target, label=failureLine)
        plt.scatter(offXTest[:len(T_target)], T_predicted[:len(T_target)], label=&#39;no_failure&#39;)
        plt.xlabel(&#34;OffsetX (m)&#34;)
        plt.ylabel(&#34;Natural period (s)&#34;)
        plt.legend()

        plt.figure(figsize=(20, 5))
        plt.title(&#34;First test with SVM regression: &#34; + str(var))
        plt.scatter(offYTest[:len(T_target)], T_target, label=failureLine)
        plt.scatter(offYTest[:len(T_target)], T_predicted[:len(T_target)], label=&#39;no_failure&#39;)
        plt.xlabel(&#34;OffsetY (m)&#34;)
        plt.ylabel(&#34;Natural period (s)&#34;)
        plt.legend()

        df = pd.DataFrame({&#34;Offset X (m)&#34;:offXTest[:len(T_target)],&#34;Offset Y (m)&#34;:offYTest[:len(T_target)], &#34;Error_&#34;+failureLine+&#34; (s)&#34;:np.array(error), &#39;T_failure&#39;:T_target[:len(T_target)], &#39;T_predicted&#39;:T_predicted[:len(T_target)]})
        fig = px.scatter(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, height=600, width=1200, color=&#34;Error_&#34;+failureLine+&#34; (s)&#34;, title=&#34;Test with SVM regression &#34;+var+&#34;: Error&#34;&#34;Error_&#34;+failureLine)
        fig.show()
        
        fig = px.histogram(df, x=&#34;Error_&#34;+failureLine+&#34; (s)&#34;, title=&#34;Error Histogram &#34; +var+ &#34; Mean: &#34;+str(np.mean([x for x in error if str(x) != &#39;nan&#39;])))
        fig.show()
        
        Tp = []
        colorTp = []
        sizeTp = []
        tam = 10
        Tp.append(T_target[0])
        sizeTp.append(tam)
        colorTp.append(0)
        for i in range(1, len(T_target)):
            Tp.append(T_target[i])
            colorTp.append(0.25)
            sizeTp.append(tam)
        
        
        Tp.append(T_predicted[0])
        colorTp.append(1)
        sizeTp.append(tam)
        for i in range(1, len(T_target)):
            Tp.append(T_predicted[i])
            colorTp.append(0.75)
            sizeTp.append(tam)
        df = pd.DataFrame({&#34;Offset X (m)&#34;:offXTest[:len(T_target)] + offXTest[:len(T_target)],&#34;Offset Y (m)&#34;:offYTest[:len(T_target)]+offYTest[:len(T_target)],&#39;Tp&#39;:np.array(Tp), &#39;Class&#39;:np.array(colorTp)})
       
        fig = px.scatter_3d(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, z=&#39;Tp&#39;, height=600, width=1140, color=&#39;Class&#39;, title=&#34;Test with SVM regression &#34;+var)      
        fig.show()
                
        
    def plotErrorGraph(self, TX_target, TY_target, TYaw_target, predictors, failureLine):
        &#39;&#39;&#39;
            ### It plots interactive graphs of the error for each axis (X, Y, Yaw)
            
              - params:
                1. **TX_target:** Calculated from the estimator
                2. **TY_target:** Calculated from the estimator
                3. **predictors:** Input of the svm regressor in order to predict Tp values
                4. **failureLine:** The line that failed
        &#39;&#39;&#39;        
        offXTest = []
        for i in range(len(predictors)):
            offXTest.append(predictors[i][0])
        offYTest = []
        for i in range(len(predictors)):
            offYTest.append(predictors[i][1])
        
        self.plotErrorGraphVar(&#39;TX&#39;, offXTest, offYTest, self.TXpredicted, TX_target, self.errorTX, failureLine)
        self.plotErrorGraphVar(&#39;TY&#39;, offXTest, offYTest, self.TYpredicted, TY_target, self.errorTY, failureLine)
        self.plotErrorGraphVar(&#39;TYaw&#39;, offXTest, offYTest, self.TYawpredicted, TYaw_target, self.errorTYaw, failureLine)
        

    def predictClasses(self):
        &#39;&#39;&#39;
            ### Predict and plot the confusion matrix of the classifier
            #### **Validation:** 5-fold cross-validation


        &#39;&#39;&#39;
        classifier = svm.SVC(kernel=&#39;rbf&#39;, C=100, gamma=0.35)#1/np.sqrt(2.8))
        scaler = StandardScaler()
        scaler.fit(self.inputClassifier)
        X = scaler.transform(self.inputClassifier)
        y = self.outputClassifier.ravel()

        scores = cross_val_score(classifier, X, y, cv=5)
        print(&#34;Accuracy: %0.2f (+/- %0.2f)&#34; % (scores.mean(), scores.std() * 2))
    
        nlabels = 5
        
        kf = KFold(5, True)
        kf.get_n_splits(X)

        matrix = [[0 for i in range(nlabels)] for k in range(nlabels)]

        for train_index, test_index in kf.split(X):

            X_train, X_test = X[train_index], X[test_index]
            y_train, y_test = y[train_index], y[test_index]

            classifier.fit(X_train, y_train)

            #plot_confusion_matrix(classifier, X_test, y_test)
            y_predict = classifier.predict(X_test)
            m = confusion_matrix(y_test,y_predict)

            #df = pd.DataFrame({&#34;stdY&#34;:column(X_test, 0),&#34;stdYaw&#34;:column(X_test, 1),&#39;label&#39;:np.array(y_test)})
            #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Test case&#34;)  
            #fig.show()

            #df = pd.DataFrame({&#34;stdY&#34;:column(X_train, 0)[classifier.support_],&#34;stdYaw&#34;:column(X_train, 1)[classifier.support_],&#39;label&#39;:np.array(y_train[classifier.support_])})
            #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Support vectors&#34;)  
            #fig.show()

            ox0 = []
            ox1 = []
            erro = []
            for i in range(len(y_test)):
                if(y_test[i] != y_predict[i]):
                    ox0.append(X_test[i][0])
                    ox1.append(X_test[i][1])
                    erro.append(y_predict[i])

            #df = pd.DataFrame({&#34;stdY&#34;:ox0,&#34;stdYaw&#34;:ox1,&#39;label&#39;:np.array(erro)})
            #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Wrong values&#34;)  
            #fig.show()

            for i in range(len(m)):
                for j in range(len(m)):
                    matrix[i][j] += m[i][j]

            classes_names = [&#39;L05&#39;, &#39;L09&#39;, &#39;L12&#39;, &#39;L18&#39;, &#39;N&#39;]
        plot_cmatrix(matrix = np.array(matrix), proportions    = True, class_names = classes_names,title = &#34;Confusion Matrix&#34;,gradient=&#39;GnBu&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.load1"><code class="name flex">
<span>def <span class="ident">load1</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the training data from 1 file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load1(self, path):
    &#39;&#39;&#39;
        Loads the training data from 1 file.

    &#39;&#39;&#39;
    #print(&#34;Loading data from: &#34;+path)
    ini = time.time()
    self.offX = SVM_classifier.carrega2(&#39;offX.txt&#39;, path)
    self.offY = SVM_classifier.carrega2(&#39;offY.txt&#39;, path)
    self.offYaw = SVM_classifier.carrega2(&#39;offYaw.txt&#39;, path)
    self.stdX = SVM_classifier.carrega2(&#39;stdX.txt&#39;, path)
    self.stdY = SVM_classifier.carrega2(&#39;stdY.txt&#39;, path)
    self.stdZ = SVM_classifier.carrega2(&#39;stdZ.txt&#39;, path)
    self.stdRoll = SVM_classifier.carrega2(&#39;stdRoll.txt&#39;, path)
    self.stdPitch = SVM_classifier.carrega2(&#39;stdPitch.txt&#39;, path)
    self.stdYaw = SVM_classifier.carrega2(&#39;stdYaw.txt&#39;, path)
    self.TX = SVM_classifier.carrega2(&#39;TX.txt&#39;, path)
    self.TY = SVM_classifier.carrega2(&#39;TY.txt&#39;, path)
    self.TYaw = SVM_classifier.carrega2(&#39;TYaw.txt&#39;, path)
    self.TYaw2 = SVM_classifier.carrega2(&#39;TYaw2.txt&#39;, path)
    fini = time.time()</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.load2"><code class="name flex">
<span>def <span class="ident">load2</span></span>(<span>self, path1, path2)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the training data when 2 files are needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load2(self, path1, path2):
    &#39;&#39;&#39;
        Loads the training data when 2 files are needed.

    &#39;&#39;&#39;
    #print(&#34;Loading data from files: no failure&#34;)
    ini = time.time()
    self.offX = SVM_classifier.carrega(&#39;offX.txt&#39;, path1, path2)
    self.offY = SVM_classifier.carrega(&#39;offY.txt&#39;, path1, path2)
    self.offYaw = SVM_classifier.carrega(&#39;offYaw.txt&#39;, path1, path2)
    self.stdX = SVM_classifier.carrega(&#39;stdX.txt&#39;, path1, path2)
    self.stdY = SVM_classifier.carrega(&#39;stdY.txt&#39;, path1, path2)
    self.stdZ = SVM_classifier.carrega(&#39;stdZ.txt&#39;, path1, path2)
    self.stdRoll = SVM_classifier.carrega(&#39;stdRoll.txt&#39;, path1, path2)
    self.stdPitch = SVM_classifier.carrega(&#39;stdPitch.txt&#39;, path1, path2)
    self.stdYaw = SVM_classifier.carrega(&#39;stdYaw.txt&#39;, path1, path2)
    self.TX = SVM_classifier.carrega(&#39;TX.txt&#39;, path1, path2)
    self.TY = SVM_classifier.carrega(&#39;TY.txt&#39;, path1, path2)
    self.TYaw = SVM_classifier.carrega(&#39;TYaw.txt&#39;, path1, path2)
    self.TYaw2 = SVM_classifier.carrega(&#39;TYaw2.txt&#39;, path1, path2)
    fini = time.time()</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotErrorGraph"><code class="name flex">
<span>def <span class="ident">plotErrorGraph</span></span>(<span>self, TX_target, TY_target, TYaw_target, predictors, failureLine)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="it-plots-interactive-graphs-of-the-error-for-each-axis-x-y-yaw">It plots interactive graphs of the error for each axis (X, Y, Yaw)</h3>
<ul>
<li>params:<ol>
<li><strong>TX_target:</strong> Calculated from the estimator</li>
<li><strong>TY_target:</strong> Calculated from the estimator</li>
<li><strong>predictors:</strong> Input of the svm regressor in order to predict Tp values</li>
<li><strong>failureLine:</strong> The line that failed</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotErrorGraph(self, TX_target, TY_target, TYaw_target, predictors, failureLine):
    &#39;&#39;&#39;
        ### It plots interactive graphs of the error for each axis (X, Y, Yaw)
        
          - params:
            1. **TX_target:** Calculated from the estimator
            2. **TY_target:** Calculated from the estimator
            3. **predictors:** Input of the svm regressor in order to predict Tp values
            4. **failureLine:** The line that failed
    &#39;&#39;&#39;        
    offXTest = []
    for i in range(len(predictors)):
        offXTest.append(predictors[i][0])
    offYTest = []
    for i in range(len(predictors)):
        offYTest.append(predictors[i][1])
    
    self.plotErrorGraphVar(&#39;TX&#39;, offXTest, offYTest, self.TXpredicted, TX_target, self.errorTX, failureLine)
    self.plotErrorGraphVar(&#39;TY&#39;, offXTest, offYTest, self.TYpredicted, TY_target, self.errorTY, failureLine)
    self.plotErrorGraphVar(&#39;TYaw&#39;, offXTest, offYTest, self.TYawpredicted, TYaw_target, self.errorTYaw, failureLine)</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotErrorGraphVar"><code class="name flex">
<span>def <span class="ident">plotErrorGraphVar</span></span>(<span>self, var, offXTest, offYTest, T_predicted, T_target, error, failureLine)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="it-plots-interactive-graphs-of-the-error-for-the-given-variable-var">It plots interactive graphs of the error for the given variable var.</h3>
<ul>
<li>
<p>The plots are:</p>
<ol>
<li>Scatter of Tp predicted and estimated over X offset</li>
<li>Scatter of Tp predicted and estimated over Y offset</li>
<li>Scatter of X offset over Y offser where the color is the error.</li>
<li>Histogram of the error</li>
<li>3D scatter plot</li>
</ol>
</li>
<li>
<p>params:</p>
<ol>
<li><strong>T_target:</strong> Calculated from the estimator</li>
<li><strong>var:</strong> Variable TX, TY, or TYaw</li>
<li><strong>offXTest:</strong> X offset values from the broken line</li>
<li><strong>offYTest:</strong> Y offset values from the broken line
</li>
<li><strong>T_predicted:</strong> Tp values from the regressor results</li>
<li><strong>T_target:</strong> Tp values from the estimator results</li>
<li><strong>error:</strong> Error measured as T_target - T_predicted</li>
<li><strong>failureLine:</strong> The line that failed</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotErrorGraphVar(self, var, offXTest, offYTest,T_predicted, T_target, error, failureLine):
    &#39;&#39;&#39;
        ### It plots interactive graphs of the error for the given variable var.
          - The plots are:
            1. Scatter of Tp predicted and estimated over X offset
            2. Scatter of Tp predicted and estimated over Y offset
            3. Scatter of X offset over Y offser where the color is the error.
            4. Histogram of the error
            5. 3D scatter plot
        
          - params:
            1. **T_target:** Calculated from the estimator
            2. **var:** Variable TX, TY, or TYaw
            3. **offXTest:** X offset values from the broken line
            3. **offYTest:** Y offset values from the broken line  
            3. **T_predicted:** Tp values from the regressor results
            3. **T_target:** Tp values from the estimator results
            3. **error:** Error measured as T_target - T_predicted
            4. **failureLine:** The line that failed
    &#39;&#39;&#39;                
    plt.figure(figsize=(20, 5))
    plt.title(&#34;First test with SVM regression: &#34; + str(var))
    plt.scatter(offXTest[:len(T_target)], T_target, label=failureLine)
    plt.scatter(offXTest[:len(T_target)], T_predicted[:len(T_target)], label=&#39;no_failure&#39;)
    plt.xlabel(&#34;OffsetX (m)&#34;)
    plt.ylabel(&#34;Natural period (s)&#34;)
    plt.legend()

    plt.figure(figsize=(20, 5))
    plt.title(&#34;First test with SVM regression: &#34; + str(var))
    plt.scatter(offYTest[:len(T_target)], T_target, label=failureLine)
    plt.scatter(offYTest[:len(T_target)], T_predicted[:len(T_target)], label=&#39;no_failure&#39;)
    plt.xlabel(&#34;OffsetY (m)&#34;)
    plt.ylabel(&#34;Natural period (s)&#34;)
    plt.legend()

    df = pd.DataFrame({&#34;Offset X (m)&#34;:offXTest[:len(T_target)],&#34;Offset Y (m)&#34;:offYTest[:len(T_target)], &#34;Error_&#34;+failureLine+&#34; (s)&#34;:np.array(error), &#39;T_failure&#39;:T_target[:len(T_target)], &#39;T_predicted&#39;:T_predicted[:len(T_target)]})
    fig = px.scatter(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, height=600, width=1200, color=&#34;Error_&#34;+failureLine+&#34; (s)&#34;, title=&#34;Test with SVM regression &#34;+var+&#34;: Error&#34;&#34;Error_&#34;+failureLine)
    fig.show()
    
    fig = px.histogram(df, x=&#34;Error_&#34;+failureLine+&#34; (s)&#34;, title=&#34;Error Histogram &#34; +var+ &#34; Mean: &#34;+str(np.mean([x for x in error if str(x) != &#39;nan&#39;])))
    fig.show()
    
    Tp = []
    colorTp = []
    sizeTp = []
    tam = 10
    Tp.append(T_target[0])
    sizeTp.append(tam)
    colorTp.append(0)
    for i in range(1, len(T_target)):
        Tp.append(T_target[i])
        colorTp.append(0.25)
        sizeTp.append(tam)
    
    
    Tp.append(T_predicted[0])
    colorTp.append(1)
    sizeTp.append(tam)
    for i in range(1, len(T_target)):
        Tp.append(T_predicted[i])
        colorTp.append(0.75)
        sizeTp.append(tam)
    df = pd.DataFrame({&#34;Offset X (m)&#34;:offXTest[:len(T_target)] + offXTest[:len(T_target)],&#34;Offset Y (m)&#34;:offYTest[:len(T_target)]+offYTest[:len(T_target)],&#39;Tp&#39;:np.array(Tp), &#39;Class&#39;:np.array(colorTp)})
   
    fig = px.scatter_3d(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, z=&#39;Tp&#39;, height=600, width=1140, color=&#39;Class&#39;, title=&#34;Test with SVM regression &#34;+var)      
    fig.show()</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotGraph"><code class="name flex">
<span>def <span class="ident">plotGraph</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="plots-a-scatter-graph-of-the-offset-x-and-offset-y-the-color-is-the-natural-period">Plots a scatter graph of the Offset X and Offset Y. The color is the natural period.</h3>
<ul>
<li>params: <ol>
<li><strong>var:</strong> Variable (TX, TY, TYaw) to color the graph</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotGraph(self, var):
    &#39;&#39;&#39;
        ### Plots a scatter graph of the Offset X and Offset Y. The color is the natural period.

          - params: 
            1. **var:** Variable (TX, TY, TYaw) to color the graph
    &#39;&#39;&#39;
    variable = self.parsing[var]
    
    df = pd.DataFrame({&#34;Offset X (m)&#34;:self.offX[:len(variable)], &#34;Offset Y (m)&#34;:self.offY[:len(variable)], &#34;Tp &#34;+str(var): np.array(variable)})
    fig = px.scatter(df, x=&#39;Offset X (m)&#39;, y=&#39;Offset Y (m)&#39;, height=600, width=1200, color=&#34;Tp &#34;+str(var), title=&#34;Natural period &#34;+str(var))
    fig.show()</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessing"><code class="name flex">
<span>def <span class="ident">preProcessing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="prepare-the-data-of-the-9-predictors">Prepare the data of the 9 predictors</h3>
<ol>
<li>offX </li>
<li>offY </li>
<li>offYaw </li>
<li>stdX
5.stdY </li>
<li>stdZ </li>
<li>stdRoll </li>
<li>stdPitch </li>
<li>stdYaw</li>
</ol>
<h3 id="prepare-the-train_data-in-case-of-training">Prepare the train_data in case of training</h3></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preProcessing(self):
    &#39;&#39;&#39;
        ### Prepare the data of the 9 predictors
        1. offX 
        2. offY 
        3. offYaw 
        4. stdX 
        5.stdY 
        6. stdZ 
        7. stdRoll 
        8. stdPitch 
        9. stdYaw
        ### Prepare the train_data in case of training
    &#39;&#39;&#39;  
    #print(&#34;Preprocessing data&#34;)
    f = []
    f.append(np.array(self.offX).reshape(-1, 1))
    f.append(np.array(self.offY).reshape(-1, 1))
    f.append(np.array(self.offYaw).reshape(-1, 1))
    f.append(np.array(self.stdX).reshape(-1, 1))
    f.append(np.array(self.stdY).reshape(-1, 1))
    f.append(np.array(self.stdZ).reshape(-1, 1))
    f.append(np.array(self.stdRoll).reshape(-1, 1))
    f.append(np.array(self.stdPitch).reshape(-1, 1))
    f.append(np.array(self.stdYaw).reshape(-1, 1))
    f = tuple(f)    
    
    self.predictors = np.hstack(f)
    #print(&#34;Predictors: &#34;, self.predictors)
    
    self.X_train = self.predictors[:]
    scaler = StandardScaler()
    scaler.fit(self.X_train)
    self.X_train = scaler.transform(self.X_train)</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessingClassifier"><code class="name flex">
<span>def <span class="ident">preProcessingClassifier</span></span>(<span>self, predictors, active_variables)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="treat-the-data-for-the-classifier">Treat the data for the classifier.</h3>
<ul>
<li>params:<ol>
<li><strong>predictors:</strong> list of objects for each group of line </li>
<li><strong>active_variables:</strong> Boolean array that determines the variables used in classification</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preProcessingClassifier(self, predictors, active_variables):

    &#39;&#39;&#39;
        ### Treat the data for the classifier.

          - params:
            1. **predictors:** list of objects for each group of line 
            2. **active_variables:** Boolean array that determines the variables used in classification

    &#39;&#39;&#39;

    f = []
    g = []
    for case in predictors:
        aux = self.preProcessingClassifier_Var(case, active_variables)
        f.append(aux[0])
        g.append(aux[1])
    f = tuple(f)
    g = tuple(g)
    
    self.inputClassifier = np.vstack(f)
    self.outputClassifier = np.vstack(g)</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessingClassifier_Var"><code class="name flex">
<span>def <span class="ident">preProcessingClassifier_Var</span></span>(<span>self, case, active_variables)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="treat-the-data-for-the-classifier">Treat the data for the classifier.</h3>
<h4 id="uses-stardard-normalization">Uses stardard normalization.</h4>
<ul>
<li>
<p>params:</p>
<ol>
<li>
<p><strong>case:</strong> Object that holds the classifier input</p>
<ul>
<li>Mean X offset</li>
<li>Mean Y offset</li>
<li>Mean Yaw offset</li>
<li>X standard deviation</li>
<li>Y standard deviation</li>
<li>Z standard deviation</li>
<li>Roll standard deviation</li>
<li>Pitch standard deviation</li>
<li>Yaw standanrd deviation</li>
</ul>
</li>
<li>
<p><strong>active_variables:</strong> Boolean array that determines the variables used in classification</p>
</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preProcessingClassifier_Var(self, case, active_variables):
    &#39;&#39;&#39;
        ### Treat the data for the classifier.
        #### Uses stardard normalization.
          
          - params:
            1. **case:** Object that holds the classifier input
                  - Mean X offset
                  - Mean Y offset
                  - Mean Yaw offset
                  - X standard deviation
                  - Y standard deviation
                  - Z standard deviation
                  - Roll standard deviation
                  - Pitch standard deviation
                  - Yaw standanrd deviation

            2. **active_variables:** Boolean array that determines the variables used in classification

    &#39;&#39;&#39;

    global teste

    self.predict(case.predictors)
    self.setError(case.TX, case.TY)
    f = []
    if(active_variables[0]):f.append(np.array(self.errorTX[:2900]).reshape(-1, 1))
    if(active_variables[1]):f.append(np.array(self.errorTY[:2900]).reshape(-1, 1))
    if(active_variables[2]):f.append(np.array(case.offX[:2900]).reshape(-1, 1))
    if(active_variables[3]):f.append(np.array(case.offY[:2900]).reshape(-1, 1))
    if(active_variables[4]):f.append(np.array(case.offYaw[:2900]).reshape(-1, 1))
    if(active_variables[5]):f.append(np.array(case.stdX[:2900]).reshape(-1, 1))
    if(active_variables[6]):f.append(np.array(case.stdY[:2900]).reshape(-1, 1))
    if(active_variables[7]):f.append(np.array(case.stdZ[:2900]).reshape(-1, 1))
    if(active_variables[8]):f.append(np.array(case.stdRoll[:2900]).reshape(-1, 1))
    if(active_variables[9]):f.append(np.array(case.stdPitch[:2900]).reshape(-1, 1))
    if(active_variables[10]):f.append(np.array(case.stdYaw[:2900]).reshape(-1, 1))
    f = tuple(f)   

    g = []
    g.append(np.array(2900*[case.label]).reshape(-1, 1))
    g = tuple(g)

    return np.hstack(f), np.hstack(g)    </code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, predictors)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="predict-the-values-of-natural-period">Predict the values of natural period</h3>
<ul>
<li>params: <ol>
<li><strong>predictors :</strong> Input of the svm regressor in order to predict Tp values</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, predictors):
    
    &#39;&#39;&#39;
        ### Predict the values of natural period

          - params: 
            1. **predictors :** Input of the svm regressor in order to predict Tp values
    &#39;&#39;&#39;

    #print(&#34;Prediction initialiation: &#34;)
    #init = time.time()
    
    self.TXpredicted = self.predictVar(&#39;TX&#39;, self.regressorTX, predictors)
    self.TYpredicted = self.predictVar(&#39;TY&#39;, self.regressorTY, predictors)
    self.TYawpredicted = self.predictVar(&#39;TYaw&#39;, self.regressorTYaw, predictors)</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predictClasses"><code class="name flex">
<span>def <span class="ident">predictClasses</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="predict-and-plot-the-confusion-matrix-of-the-classifier">Predict and plot the confusion matrix of the classifier</h3>
<h4 id="validation-5-fold-cross-validation"><strong>Validation:</strong> 5-fold cross-validation</h4></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predictClasses(self):
    &#39;&#39;&#39;
        ### Predict and plot the confusion matrix of the classifier
        #### **Validation:** 5-fold cross-validation


    &#39;&#39;&#39;
    classifier = svm.SVC(kernel=&#39;rbf&#39;, C=100, gamma=0.35)#1/np.sqrt(2.8))
    scaler = StandardScaler()
    scaler.fit(self.inputClassifier)
    X = scaler.transform(self.inputClassifier)
    y = self.outputClassifier.ravel()

    scores = cross_val_score(classifier, X, y, cv=5)
    print(&#34;Accuracy: %0.2f (+/- %0.2f)&#34; % (scores.mean(), scores.std() * 2))

    nlabels = 5
    
    kf = KFold(5, True)
    kf.get_n_splits(X)

    matrix = [[0 for i in range(nlabels)] for k in range(nlabels)]

    for train_index, test_index in kf.split(X):

        X_train, X_test = X[train_index], X[test_index]
        y_train, y_test = y[train_index], y[test_index]

        classifier.fit(X_train, y_train)

        #plot_confusion_matrix(classifier, X_test, y_test)
        y_predict = classifier.predict(X_test)
        m = confusion_matrix(y_test,y_predict)

        #df = pd.DataFrame({&#34;stdY&#34;:column(X_test, 0),&#34;stdYaw&#34;:column(X_test, 1),&#39;label&#39;:np.array(y_test)})
        #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Test case&#34;)  
        #fig.show()

        #df = pd.DataFrame({&#34;stdY&#34;:column(X_train, 0)[classifier.support_],&#34;stdYaw&#34;:column(X_train, 1)[classifier.support_],&#39;label&#39;:np.array(y_train[classifier.support_])})
        #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Support vectors&#34;)  
        #fig.show()

        ox0 = []
        ox1 = []
        erro = []
        for i in range(len(y_test)):
            if(y_test[i] != y_predict[i]):
                ox0.append(X_test[i][0])
                ox1.append(X_test[i][1])
                erro.append(y_predict[i])

        #df = pd.DataFrame({&#34;stdY&#34;:ox0,&#34;stdYaw&#34;:ox1,&#39;label&#39;:np.array(erro)})
        #fig = px.scatter(df, x=&#39;stdY&#39;, y=&#39;stdYaw&#39;, height=600, width=1140,color=&#39;label&#39;, title=&#34;Wrong values&#34;)  
        #fig.show()

        for i in range(len(m)):
            for j in range(len(m)):
                matrix[i][j] += m[i][j]

        classes_names = [&#39;L05&#39;, &#39;L09&#39;, &#39;L12&#39;, &#39;L18&#39;, &#39;N&#39;]
    plot_cmatrix(matrix = np.array(matrix), proportions    = True, class_names = classes_names,title = &#34;Confusion Matrix&#34;,gradient=&#39;GnBu&#39;)</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predictVar"><code class="name flex">
<span>def <span class="ident">predictVar</span></span>(<span>self, var, regressor, predictors)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="predicts-the-values-of-natural-period-in-the-given-variable-var">Predicts the values of natural period in the given variable var</h3>
<ul>
<li>params:<ol>
<li><strong>var
:</strong> variable to calculate the natural period</li>
<li><strong>regressor
:</strong> trained SVM regressor</li>
<li><strong>predictors
:</strong> input of the regressor</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predictVar(self, var, regressor, predictors):

    &#39;&#39;&#39;
        ### Predicts the values of natural period in the given variable var

          - params:
            1. **var         :** variable to calculate the natural period
            2. **regressor   :** trained SVM regressor
            3. **predictors  :** input of the regressor

    &#39;&#39;&#39;
    variable = self.parsing[var]

    scaler = StandardScaler()
    scaler.fit(predictors)
    predictors = scaler.transform(predictors)

    print(&#34;Predicting &#34;, var)
    ini = time.time()
    Tpredicted = regressor.predict(predictors)
    fini = time.time()
    print(&#34;Finished: &#34;, fini - ini)
    
    return Tpredicted</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.setError"><code class="name flex">
<span>def <span class="ident">setError</span></span>(<span>self, TX_target, TY_target)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="calculates-the-error-t_estimated-t_predicted">Calculates the error: T_estimated - T_predicted</h3>
<ul>
<li>params:<ol>
<li><strong>TX_target:</strong> Calculated from the estimator</li>
<li><strong>TY_target:</strong> Calculated from the estimator</li>
<li><strong>TYaw_target:</strong> Calculated from the estimator</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setError(self, TX_target, TY_target):
    &#39;&#39;&#39;
        ### Calculates the error: T_estimated - T_predicted

          - params:
            1. **TX_target:** Calculated from the estimator
            2. **TY_target:** Calculated from the estimator
            3. **TYaw_target:** Calculated from the estimator
    &#39;&#39;&#39;        
    self.errorTX = self.setErrorVar(&#39;TX&#39;, TX_target)
    self.errorTY = self.setErrorVar(&#39;TY&#39;, TY_target)</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.setErrorVar"><code class="name flex">
<span>def <span class="ident">setErrorVar</span></span>(<span>self, var, T_target)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="calculates-the-error-for-the-given-variable-in-var">Calculates the error for the given variable in var</h3>
<ul>
<li>params:<ol>
<li><strong>T_target :</strong> Calculated from the estimator</li>
<li><strong>var
:</strong> Variable (TX, TY, TYaw) from the regressor</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setErrorVar(self, var, T_target):
    &#39;&#39;&#39;
        ### Calculates the error for the given variable in var

          - params:
            1. **T_target :** Calculated from the estimator
            2. **var      :** Variable (TX, TY, TYaw) from the regressor
    &#39;&#39;&#39;        
    if var == &#39;TX&#39;: variable = self.TXpredicted
    if var == &#39;TY&#39;: variable = self.TYpredicted
    if var == &#39;TYaw&#39;: variable = self.TYawpredicted
    
    error = []
    for i in range(min(len(T_target), len(variable))):
        error.append(T_target[i] - variable[i])
    
    return error</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.training"><code class="name flex">
<span>def <span class="ident">training</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="instantiate-and-train-the-svm-regressor">Instantiate and train the SVM regressor</h3>
<ol>
<li><strong>BoxConstraint:</strong> Interquartile range of the variable / 1.349</li>
<li><strong>Epsilon:</strong> 2*IQR / 13.49</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def training(self):
    &#39;&#39;&#39;
        ### Instantiate and train the SVM regressor
        
        1. **BoxConstraint:** Interquartile range of the variable / 1.349
        2. **Epsilon:** 2*IQR / 13.49
    
    &#39;&#39;&#39;        
    print(&#34;Training initialization&#34;)
    ini = time.time()
    self.regressorTX = self.trainingVar(&#39;TX&#39;)
    self.regressorTY = self.trainingVar(&#39;TY&#39;)
    self.regressorTYaw = self.trainingVar(&#39;TYaw&#39;)
    
    #self.regressorTYaw2 = SVM_classifier.trainingVar(&#39;TYaw2&#39;)
    
    fini = time.time()
    print(&#34;Finished training - Total elapsed time: &#34;, fini - ini)</code></pre>
</details>
</dd>
<dt id="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.trainingVar"><code class="name flex">
<span>def <span class="ident">trainingVar</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="train-the-svr-with-the-data-loaded-previously">Train the SVR with the data loaded previously.</h3>
<ul>
<li>params:<ol>
<li><strong>var:</strong> variable to train (TX, TY, TYaw)
</li>
</ol>
</li>
<li>returns:<ol>
<li><strong>regressor:</strong> the SVM regressor trained</li>
</ol>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trainingVar(self, var): 
    &#39;&#39;&#39;
        ### Train the SVR with the data loaded previously.
          
          - params:
            1. **var:** variable to train (TX, TY, TYaw)  
          - returns:
            1. **regressor:** the SVM regressor trained
    &#39;&#39;&#39;
    variable = self.parsing[var]
    
    print(&#34;Training for: &#34;, var)
    
    ini = time.time()

    responseScale = sci.stats.iqr(variable)
    
    boxConstraint = responseScale/1.349;
    #boxConstraint = 135
    #gamma = 1/9
    #gamma = 0.01
    gamma=&#39;auto&#39;
    #epsilon = 1
    epsilon = 2*responseScale/13.49;
    
    regressor = svm.SVR(&#39;rbf&#39;, C=boxConstraint, gamma=gamma, epsilon=epsilon)
    regressor.fit(self.X_train, variable)
    fini = time.time()
    
    print(&#34;Finished: &#34;, fini - ini)
    
    return regressor</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Frequencia_Natural.Classificador" href="index.html">Frequencia_Natural.Classificador</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier">SVM_classifier</a></code></h4>
<ul class="">
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.load1" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.load1">load1</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.load2" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.load2">load2</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotErrorGraph" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotErrorGraph">plotErrorGraph</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotErrorGraphVar" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotErrorGraphVar">plotErrorGraphVar</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotGraph" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.plotGraph">plotGraph</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessing" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessing">preProcessing</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessingClassifier" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessingClassifier">preProcessingClassifier</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessingClassifier_Var" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.preProcessingClassifier_Var">preProcessingClassifier_Var</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predict" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predict">predict</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predictClasses" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predictClasses">predictClasses</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predictVar" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.predictVar">predictVar</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.setError" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.setError">setError</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.setErrorVar" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.setErrorVar">setErrorVar</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.training" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.training">training</a></code></li>
<li><code><a title="Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.trainingVar" href="#Frequencia_Natural.Classificador.ClassificadorTp.SVM_classifier.trainingVar">trainingVar</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>